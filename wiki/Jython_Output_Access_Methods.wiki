#sidebar Jython_TableOfContents
= Access Methods =
*Table of contents*
<wiki:toc max_depth="3" />

== Introduction ==

uimaFIT supports several convenient methods to access the annotations added by the pipelines components. In the previous code examples we mainly used `select` to select all annotations of a certain types. In this tutorial we will introduce the different methods in a more structured way and will show some handy code examples.

Also please check the following site from the uimaFIT documentation: [https://uima.apache.org/d/uimafit-current/tools.uimafit.book.html#d5e218 uimaFIT Guide and References].


== Annotations and Type System ==
As mentioned in the introduction, UIMA uses the concept of annotations. Each information, for example the part-of-speech-tag for a word, is added as an annotation to the CAS (Common Analysis System). Different annotations are represented by different types, e.g. there are types for part-of-speech information, types for the lemma of word, types for named entity information and so on. Understanding which annotations with which types are added by a component is a crucial part for further using the results. For an overview of the type system used by DKPro, please see the following page in the main DKPro wiki: [https://code.google.com/p/dkpro-core-asl/wiki/TypeSystem DKPro Type System].

The following script runs some components like POS-tagging and NER and then prints *all* annotations that are added to the CAS.

{{{
# Filename: print_all_annotations.jy
}}}


You can execute this script by calling:
{{{
jython print_all_annotations.jy examples/example-en.txt en
}}}

The output will be quite long and look a bit confusing in the beginning. Here are the first lines of the output:

{{{
[de.tudarmstadt.ukp.dkpro.core.api.metadata.type.DocumentMetaData][org.apache.uima.jcas.tcas.DocumentAnnotation](0, 120) Some students like to study in the mornings. Other students like to do so in the evenings. And some don't study at all.
DocumentMetaData
   sofa: _InitialView
   begin: 0
   end: 120
   language: "en"
   documentTitle: ""
   documentId: ""
   documentUri: "file:/home/reimers/examples/example-en.txt"
   collectionId: "file:/home/reimers/examples/"
   documentBaseUri: "file:/home/reimers/examples/"
   isLastSegment: false


[de.tudarmstadt.ukp.dkpro.core.api.segmentation.type.Sentence][org.apache.uima.jcas.tcas.Annotation](0, 44) Some students like to study in the mornings.
Sentence
   sofa: _InitialView
   begin: 0
   end: 44

[de.tudarmstadt.ukp.dkpro.core.api.segmentation.type.Lemma][org.apache.uima.jcas.tcas.Annotation](0, 4) Some
Lemma
   sofa: _InitialView
   begin: 0
   end: 4
   value: "some"

[de.tudarmstadt.ukp.dkpro.core.api.segmentation.type.Token][org.apache.uima.jcas.tcas.Annotation](0, 4) Some
Token
   sofa: _InitialView
   begin: 0
   end: 4
   parent: <null>
   lemma: Lemma
      sofa: _InitialView
      begin: 0
      end: 4
      value: "some"
   stem: <null>
   pos: ART
      sofa: _InitialView
      begin: 0
      end: 4
      PosValue: "DT"

[de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.ART][de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS](0, 4) Some
ART
   sofa: _InitialView
   begin: 0
   end: 4
   PosValue: "DT"

}}}

The different annotations are separated by an empty line. The information in the first two square-brackets are the type and the parent-type. For example for the last paragraph in the above output. There, we have the type `de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.ART` and the parent of this annotation is of type `de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS`. The POS-tagger adds for each article an annotation of type `ART`. This type, as well as all other POS-types, are derived from the `POS`-type. So in case we like to get all articles, we can either use the `select`-method and search only for annotations of type `ART` or we can select als `POS`-annotations and then check the `PosValue` for the correct type (later more).

Below the class and superclass, you can find accessible fields for the types. So for example for the POS-annotation of _Some_ you cann access the `sofa`, the `begin`, the `end` and the `PosValue`-attributes. The `sofa` (Subject of Analysis) contains the used view. You can have different views on one text, for example you could have a view containing the English version of a text and a different view containing the corresponding German version of the same text. By using different views / Sofas, you can process both versions in a single pipeline. But usually we have only a single view, the `_InitialView`.

`begin` and `end` stands for the beginning and ending of the annotation, i.e. in this case the annotation spans from character 0 to character 4. The final attribute you can access for the above example is the `PosValue`, which contains the more specific POS information. In this case, _Some_ is tagged as a `DT`.


The different attributes can easily be accessed within Jython by calling `myVariableName.attributeName`. *Note*, to access the attributes, the first character must *always* be in lowercase. So the correct way to access the POS-value is `myVariableName.posValue`.

Some annotations, like the `Token`-annotations, can also reference to other annotations (if present). For example the `Token`-annotation contains also the information about the lemma, about the stem and about the POS-tag of the word (of course only if you used a lemmatizer/stemmer/POS-tagger). So lets say the variable `myToken` is of Type `Token`, then you can access the POS-value for this Token via `myToken.pos.posValue`.